---
layout: page
title: "Symbiosis in the Sea"
wmd_project: Selection_Gradients
---
This model for symbiotic guest-host interaction in the sea is based on
Roughgarden's 1975 paper, which considers selection on the guest only.

Here we add fairly arbitrary functional forms to include the host dynamics
in the model, which retaining the Lotka-Volterra form which lets us looks
at adaptive motion in the plane of interaction coefficients.

The guest dynamics:

\[* \frac{dn}{n dt} = r_g + a_{gH} N + a_{gg} n \].

The host strategy/phenotype is

* $$X_a$$: investment for/against ($$+/-$$) association ("colonization" in the original) by guest
* $$X_t$$: investment for/against transfer of resources ("exploitation") by guest (given association).

\[* \frac{dN}{N dt} = r_H + a_{Hg} n + a_{HH} N \]

let $$a_{gg}$$ and $$a_{HH}$$ be constant, uninteresting to adaptation.

Investment has cost so $$r_H$$ is at maximum at $$X_a=X_t=0$$.

I propose

* $$p(x_a,X_a)$$: probability of association per pair of individuals

on host side:

* $$C_g(X_a)$$: general (density independent) cost of investment re association
* $$C_a(X_a)$$: per-guest cost of investment re association
* $$C_t(X_t)$$: cost of investment re transfer
* (and add density-independent investment re transfer?)
* $$B(x_t,X_t)$$: benefit ($$+/-$$) to individual host of transfer with individual guest. Not including $$C_t$$.
* $$K$$: density dependence among hosts

on guest side:

* $$c_g(x_a)$$: search cost
* $$c_a(x_a)$$: cost of association after host is found
* $$c_t(x_t)$$: cost of investment in transfer
* $$b(x_t,X_t)$$: benefit to guest of transfer
* $$k$$: density dependence among guests (does this make sense?)

So we then have

\[* \frac{dn}{n dt} = r_0 - c_g(x_a) + (p(x_a,X_a) (b(x_t,X_t) - c_t(x_t)) - c_a(x_a)) N - k n\\
 \frac{dN}{N dt} = R_0 - C_g(X_a) + (p(x_a,X_a) (B(x_t,X_t) - C_t(X_t)) - C_a(X_a)) n - K N
\]

This is oddly symmetric - maybe I abstracted it too much.  But one asymmetry is that the benefit to the host can be positive or negative, while it's assumed positive for the guest.  Thus the host might want to invest in defense against guests, while guests will always want to associate and transfer.

<source-file filename=seamodel.py display=none>
from sage.all import * 
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings

# Model organized as follows:
#  population index is (type, number), with type either g or H

type_H, type_g = 0, 1
var('H g a t')

## indexing functions for sea model
def Xfn( (t,i) ):
	return subscriptedsymbol( 'N' if t == type_H else 'n', i )
def Rfn( (t,i) ):
	return subscriptedsymbol( 'R' if t == type_H else 'r', i )
def pfn( (t,i) ):
	return indexer( lambda (s,j): subscriptedsymbol( 'p', i, j ) )
def bfn( (t,i) ):
	return indexer( lambda (s,j): subscriptedsymbol( 'b', i, j ) )
def Bfn( (t,i) ):
	return indexer( lambda (s,j): subscriptedsymbol( 'B', i, j ) )
def cgfn( (t,i) ):
	return subscriptedsymbol( 'C' if t == type_H else 'c', g, i )
def cafn( (t,i) ):
	return subscriptedsymbol( 'C' if t == type_H else 'c', a, i )
def ctfn( (s,i) ):
	return subscriptedsymbol( 'C' if s == type_H else 'c', t, i )
def Kfn( (t,i) ):
	return subscriptedsymbol( 'K' if t == type_H else 'k', i )

class SeaSymbiosisModel(dynamicalsystems.PopulationDynamicsSystem):
    def __init__(
	self,
	x_indices=None,
	X = indexer( Xfn ),
	r_indexer = indexer( Rfn ),
	p_indexer = indexer( pfn ),
	b_indexer = indexer( bfn ),
	B_indexer = indexer( Bfn ),
	cg_indexer = indexer( cgfn ),
	ca_indexer = indexer( cafn ),
	ct_indexer = indexer( ctfn ),
	K_indexer = indexer( Kfn ),
	bindings=Bindings()):
	self._indexers = { 'X': X,
		'r':r_indexer, 'p':p_indexer, 'b':b_indexer, 'B':B_indexer,
		'c_g':cg_indexer, 'c_a':ca_indexer, 'c_t':ct_indexer,
		'c_g':cg_indexer, 'c_a':ca_indexer, 'c_t':ct_indexer,
		'K':K_indexer }
	#print 'debug:', t_indexer[(type_H,0)], 'done'; sys.stdout.flush()
	from sage.symbolic.function_factory import function
	self._names = dict( 
		#[ (n, SR.symbol(n)) for n in ('r_0', 'R_0') ] +
		#[ (n, function(n)) for n in ('p', 'c_g', 'c_a', 'c_t', 'b', 'C_g', 'C_a', 'C_t', 'B') ] +
		self._indexers.items()
	)
	super(SeaSymbiosisModel,self).__init__(
	    [], x_indices, X, bindings=bindings
	)
    def flow(self):
	return self.make_flow( **self._names )
    def make_flow(self, X, r, p, c_g, c_a, c_t, b, B, K ):
	return dict(
	    [ (X[g], X[g]*(r[g] - c_g[g] +
		sum( (p[g][h] * (b[g][h] - c_t[g]) - c_a[g])*X[h]
		    for h in self._population_indices if h[0] == type_H ) +
		sum( - K[g1] * X[g1]
		    for g1 in self._population_indices if g1[0] == type_g ) )
	      ) for g in self._population_indices if g[0] == type_g ] +
	    [ (X[h], X[h]*(r[h] - c_g[h] +
		sum( (p[g][h] * (B[g][h] - c_t[h]) - c_a[h])*X[g]
		    for g in self._population_indices if g[0] == type_g ) +
		sum( - K[h1] * X[h1]
		    for h1 in self._population_indices if h1[0] == type_H ) )
	      ) for h in self._population_indices if h[0] == type_H ]
	)
    def mutate(self, resident_index):
	t,i = resident_index
	mutant_index = ( t, 1 + max( j for tt,j in self._population_indices if tt == t ) )
	self.set_population_indices( self._population_indices + [ mutant_index ] )
	return mutant_index
    def fake_population_index(self):
	return ('x','x')

## used in adaptive dynamics
def bcfn( (t,i) ):
	return ( Bfn( (type_g,0) )[(t,i)] if t == type_H
		else bfn( (t,i) )[(type_H,0)] )
def pcfn( (t,i) ):
	return ( pfn( (type_g,0) )[(t,i)] if t == type_H
		else pfn( (t,i) )[(type_H,0)] )

def xmfn( (s,i) ):
	return subscriptedsymbol( 'X' if s == type_H else 'x', t, i)
def xafn( (t,i) ):
	return subscriptedsymbol( 'X' if t == type_H else 'x', a, i)
t_indexer = indexer( xmfn )
a_indexer = indexer( xafn )

def rffn( (t,i) ):
	return function('R' if t == type_H else 'r')(a_indexer[(t,i)],t_indexer[(t,i)])
def cgffn( (t,i) ):
	return function('C_g' if t == type_H else 'c_g')(a_indexer[(t,i)])
def caffn( (t,i) ):
	return function('C_a' if t == type_H else 'c_a')(a_indexer[(t,i)])
def ctffn( (t,i) ):
	return function('C_t' if t == type_H else 'c_t')(t_indexer[(t,i)])
def pffn( ix ):
	return indexer( lambda jx: function('p')(a_indexer[ix],a_indexer[jx]) )
def bffn( ix ):
	return indexer( lambda jx: function('b')(t_indexer[ix],t_indexer[jx]) )
def Bffn( ix ):
	return indexer( lambda jx: function('B')(t_indexer[ix],t_indexer[jx]) )
def Kffn( (t,i) ):
	return SR.symbol( 'K' if t == type_H else 'k' )
def varfix( vartex ):
	for st,lx in vartex.iteritems():
		var( st, latex_name=lx )
</source-file>

<source-file filename=sea.sage.step display=none>
# requires: seamodel.py
# produces: sea.sobj sea.sage.out.tex
from sage.all import * 
from sage.misc.latex import _latex_file_
import seamodel, dynamicalsystems

# now that I've defined the general resource-competition model, let's
# create a 1-resource, 1-population instantiation to work with
sea = seamodel.SeaSymbiosisModel(
    x_indices=[(seamodel.type_H,0),(seamodel.type_g,0)]
)

ltx = dynamicalsystems.latex_output( 'sea.sage.out.tex' )
ltx.write( 'The dynamics:' )
ltx.write( sea )

ltx.close()
save_session( 'sea' )
</source-file>

<project-file filename=sea.sage.out.tex/>

<source-file filename=sea-adap.sage.step display=none>
# requires: sea.sobj
# produces: sea-adap.sobj sea-adap.sage.out.tex
from sage.all import * 
from sage.misc.latex import _latex_file_
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings
from seamodel import *

load_session( 'sea' )
ltx = dynamicalsystems.latex_output( 'sea-adap.sage.out.tex' )

sea_adap_c = dynamicalsystems.AdaptiveDynamicsModel( 
    sea,
    [ sea._indexers[s] for s in ('r', 'c_g','c_a','c_t') ] +
    [ indexer( bcfn ), indexer( pcfn ) ],
    equilibrium=sea.symbolic_equilibria()
)

ltx.write( 'Whence the selective pressure on the ecological quantities is' )
ltx.write( dynamicalsystems.dgroup( [ [ v, sea_adap_c._S[v] ] for v in sea_adap_c._vars ], op=r'\to' ) )
#ltx.write_environment( 'align*', '\\\\\n  '.join( r'\frac{d%s}{dt} &\propto %s' % (dynamicalsystems.latex_math(v), dynamicalsystems.latex_math(sea_adap_c._S[v])) for v in sea_adap_c._vars ) )

## phenotype indexers for sea correlation

from sage.symbolic.function_factory import function
sea_f = SeaSymbiosisModel(
	x_indices=[(type_H,0),(type_g,0)],
	r_indexer =indexer( rffn ),
	cg_indexer=indexer( cgffn ),
	ca_indexer=indexer( caffn ),
	ct_indexer=indexer( ctffn ),
	p_indexer =indexer( pffn ),
	b_indexer =indexer( bffn ),
	B_indexer =indexer( Bffn ),
	K_indexer =indexer( Kffn )
)

ltx.write( 'Dynamics with constraints:' )
ltx.write( sea_f )

sea_adap_f = dynamicalsystems.AdaptiveDynamicsModel( 
    sea_f,
    [ a_indexer, t_indexer ],
    equilibrium=sea_f.symbolic_equilibria(),
    workaround_limits=True,
    late_bindings = Bindings( gamma=1 )
)

seaquil = sea_f.interior_equilibria()

ltx.write( 'And selective pressure on constraining characters is' )
ltx.write( dynamicalsystems.dgroup( [ [ v, sea_adap_f._S[v] ] for v in sea_adap_f._vars ], op=r'\propto' ) )

ltx.close()

_save_symbols = { sv:lv for sv,lv in ( (str(v), latex(v)) for v in sage.symbolic.ring.pynac_symbol_registry.values() ) if sv != lv }
save_session('sea-adap')

</source-file>

<project-file filename=sea-adap.sage.out.tex/>

<source-file filename=sea-down.sage.step display=none>
# requires: sea-adap.sobj
# produces: sea-down.sobj sea-down.sage.out.tex
from sage.all import * 
from sage.misc.latex import _latex_file_
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings
from seamodel import *

load_session( 'sea-adap' )
for k,l in _save_symbols.iteritems(): SR.symbol( k, latex_name=l ) 
ltx = dynamicalsystems.latex_output( 'sea-down.sage.out.tex' )

## baseline bindings for selection on investments x_a, x_t, X_a, X_t
var('y')
base_b = Bindings(
    dynamicalsystems.FunctionBindings(
	## R_0 maximized at x_a == x_t == 0
	R = SR(1).function(x,y),
	r = SR(1).function(x,y),
    ),
    K = 1, k=1
)

## bindings for no ability to invest in association
zero_ass_b = Bindings(
    dynamicalsystems.FunctionBindings(
	## prob of association
	p = SR(0).function(x,y),
	## density independent investment in association
	C_g = SR(0).function(x),
	c_g = SR(0).function(x),
	## investment in association per interaction
	C_a = SR(0).function(x),
	c_a = SR(0).function(x),
    )
)

## fixed association
fixed_ass_b = Bindings(
    dynamicalsystems.FunctionBindings(
	## prob of association
	p = SR('p').function(x,y),
	## density independent investment in association
	C_g = SR(0).function(x),
	c_g = SR(0).function(x),
	## investment in association per interaction
	C_a = SR(0).function(x),
	c_a = SR(0).function(x),
    )
)

## variable investment in association
base_ass_b = Bindings(
    dynamicalsystems.FunctionBindings(
	## cost re association per interaction
	C_a = (x^2).function(x),
	c_a = (x^2).function(x),
	## density independent investment in association
	C_g = SR(0).function(x),
	c_g = SR(0).function(x),
	## prob of association
	# not defined here in base bindings
    )
)

## variable association, with logistic-shaped p function
exp_ass_b = Bindings( base_ass_b,
    dynamicalsystems.FunctionBindings(
	## prob of association
	#p = (1 / (1 + exp(-(x**2+y)))).function(x,y),
	p = (1 / (1 + exp(-(x+y)))).function(x,y),
    )
)

## variable association, with linear p function
## requires x_a, X_a stay in [-1,1]
linear_ass_b = Bindings( base_ass_b,
    dynamicalsystems.FunctionBindings(
	## prob of association
	p = (1/2 + (x+y)/4).function(x,y)
    )
)

## bindings for no ability to invest in transfer
zero_tran_b = Bindings(
    dynamicalsystems.FunctionBindings(
	## benefit to guest of transfer
	b = SR(0).function(x,y),
	## benefit to host of transfer
	B = SR(0).function(x,y),
	## investment in transfer per interaction
	C_t = SR(0).function(x),
	c_t = SR(0).function(x)
    )
)

## for fixed nonzero transfer
fixed_tran_b = Bindings(
    dynamicalsystems.FunctionBindings(
	## benefit to guest of transfer
	b = SR(1).function(x,y),
	## benefit to host of transfer
	B = SR(1).function(x,y),
	## investment in transfer per interaction
	C_t = SR(0).function(x),
	c_t = SR(0).function(x)
    )
)

## variable investment in transfer
base_tran_b = Bindings(
    dynamicalsystems.FunctionBindings(
	## cost re transfer per interaction
	C_t = (x^2).function(x),
	c_t = (x^2).function(x),
    )
)

## variable transfer, with equal and opposite benefits
diag_tran_b = Bindings( base_tran_b,
    dynamicalsystems.FunctionBindings(
	## benefit to guest of transfer
	b = (x+y).function(x,y), #x.function(x,y),
	## benefit to host of transfer
	B = (-(x+y)).function(x,y), #y.function(x,y)
    )
)

## variable transfer, with generic linear benefit functions
linear_tran_b = Bindings( base_tran_b,
    dynamicalsystems.FunctionBindings(
	## benefit to guest of transfer
	b = SR('v*x+w*y').function(x,y),
	## benefit to host of transfer
	B = SR('V*x+W*y').function(x,y),
	## bind v,w,V,W yourself
    )
)

## down_b was once intended to be a setting where investments go down.
## name persists.
down_b = base_b + exp_ass_b + diag_tran_b

ltx.write( 'Here are some pessimistic bindings:', down_b )
sea_down = down_b(sea_f)

ltx.write( 'Dynamics with pessimistic functions:' )
ltx.write( sea_down )

starting_comm = Bindings( **{ x:0 for x in ('x_a_0', 'x_t_0', 'X_a_0','X_t_0') } )
starting_comm.bind_in_place( x_a_0=0.01, X_t_0=-0.008 )

starting_pop = Bindings( N_0=0.1r, n_0=0.2r )

sea_adap_down = down_b(sea_adap_f)
ltx.write( 'And pessimistic adaptive dynamics is' )
ltx.write( sea_adap_down )

sea_adap_down.bind_in_place( seaquil[0] )
#ltx.write( 'With equilibrium populations is', sea_adap_down )
ltx.write( 'And at starting point ', vector( [ starting_comm(v) for v in sea_adap_down._vars ] ), ' is', starting_comm(sea_adap_down) )

ltx.close()
_save_symbols = { sv:lv for sv,lv in ( (str(v), latex(v)) for v in sage.symbolic.ring.pynac_symbol_registry.values() ) if sv != lv }
save_session('sea-down')
</source-file>

<source-file filename=sea-down-test.sage.step display=none>
# requires: sea-down.sobj
# produces: sea-down-test.svg
from sage.all import * 
from sage.misc.latex import _latex_file_
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings
from seamodel import *

load_session( 'sea-down' )

#test_dyn = starting_comm( sea_down ).solve( starting_pop )
#test_dyn.plot( 't', sea_down._vars ).save( filename='sea-down-test.svg', figsize=(4,3) )

adap_traj = sea_adap_down.solve( starting_comm )

adap_traj.plot( 't', sea_adap_down._vars ).save( filename='sea-down-test.svg', figsize=(4,3) )
</source-file>

<source-file filename=sea-vf.sage.step display=none>
# requires: sea-down.sobj
# produces: sea-vf-X.svg sea-vf-x.svg sea-vf-c.svg sea-vf-m.svg
from sage.all import * 
from sage.misc.latex import _latex_file_
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings
from seamodel import *

xydiu

load_session( 'sea-down' )

sdx = sea_adap_down.limit( X_a_0=0, X_t_0=0 )
vfp = sdx.plot_vector_field( (SR('x_a_0'),-1,1), (SR('x_t_0'),-1,1) )
#vfp += sdx.plot_isoclines( (SR('x_a_0'),-1,1), (SR('x_t_0'),-1,1) )
vfp.save( filename='sea-vf-x.svg', figsize=(4,4) )

sdx = sea_adap_down.limit( x_a_0=0, x_t_0=0 )
vfp = sdx.plot_vector_field( (SR('X_a_0'),-1,1), (SR('X_t_0'),-1,1) )
vfp.save( filename='sea-vf-X.svg', figsize=(4,4) )

sdx = sea_adap_down.limit( X_t_0=0, x_t_0=0 )
vfp = sdx.plot_vector_field( (SR('x_a_0'),-1,0.9), (SR('X_a_0'),-1,0.9) )
vfp.save( filename='sea-vf-c.svg', figsize=(4,4) )
</source-file>

# The base model without symbiosis dynamics

<source-file filename=sea-zero.sage.step display=none>
# requires: sea-down.sobj
# produces: sea-zero.sage.out.tex sea-zero.sobj
from sage.misc.latex import _latex_file_
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings
from seamodel import *

load_session( 'sea-down' )
for k,l in _save_symbols.iteritems(): SR.symbol( k, latex_name=l ) 

ltx = dynamicalsystems.latex_output( 'sea-zero.sage.out.tex' )

sea_zero = sea_f.bind( base_b, zero_ass_b, fixed_tran_b )

ltx.write( 'For the base dynamics without symbiosis, we set', base_b, zero_ass_b )
ltx.write( 'Dynamics with no symbiosis:' )
ltx.write( sea_zero )

sea_adap_zero = sea_adap_f.bind( base_b, zero_ass_b, fixed_tran_b )
ltx.write( 'And its adaptive dynamics is' )
ltx.write( sea_adap_zero )

sea_adap_zero.bind_in_place( seaquil[0] )
#ltx.write( 'With equilibrium populations is', sea_adap_down )
#ltx.write( 'And at starting point ', vector( [ starting_comm(v) for v in sea_adap_zero._vars ] ), ' is', starting_comm(sea_adap_zero) )

adap_traj = sea_adap_zero.solve( starting_comm )
adap_traj.plot( 't', sea_adap_zero._vars ).save( filename='sea-zero-ts.svg', figsize=(4,3) )

ltx.close()
save_session('sea-zero')
</source-file>

<project-file filename=sea-zero.sage.out.tex/>

<project-file filename=sea-zero-ts.svg/>

Since here we've declared that there is no association, and hence no
transfer, and no cost or benefit whatsoever to investment in either,
investment remains fixed at its initial value of zero.

# Evolution of association investment

<source-file filename=sea-ass.sage.step display=none>
# requires: sea-down.sobj
# produces: sea-ass.sage.out.tex
# produces: sea-ass-ts.svg sea-ass-sel.tex
from sage.all import * 
from sage.misc.latex import _latex_file_
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings
from seamodel import *

load_session( 'sea-down' )
for k,l in _save_symbols.iteritems(): SR.symbol( k, latex_name=l ) 

ltx = dynamicalsystems.latex_output( 'sea-ass.sage.out.tex' )

sea_ass = sea_f.bind( base_b, exp_ass_b, fixed_tran_b )

ltx.write( 'To study the incentive structure for association, we set', exp_ass_b )

ltx.write( 'Dynamics with association only:', sea_f.bind( base_b, fixed_tran_b ) )
ltx.write( 'Or', sea_ass )

sea_adap_ass_formal = sea_adap_f.bind( base_b, fixed_tran_b )
sea_adap_ass = sea_adap_ass_formal.bind( exp_ass_b )
ltx.write( 'And its adaptive dynamics is' )
ltx.write( sea_adap_ass_formal, 'Or ', sea_adap_ass )

sea_adap_ass.bind_in_place( seaquil[0] )
#ltx.write( 'With equilibrium populations is', sea_adap_ass )
#ltx.write( 'And at starting point ', vector( [ starting_comm(v) for v in sea_adap_ass._vars ] ), ' is', starting_comm(sea_adap_ass) )

adap_traj = sea_adap_ass.solve( starting_comm )
adap_traj.plot( 't', [ a_indexer[i] for i in sea_adap_ass._popdyn_model._population_indices ] ).save( filename='sea-ass-ts.svg', figsize=(4,3) )

ltx.close()

ltx = dynamicalsystems.latex_output( 'sea-ass-sel.tex' )

ltx.write( 'The selective pressures on investment are' )
ltx.write( dynamicalsystems.dgroup( [ [ a_indexer[i], sea_adap_ass_formal._S[a_indexer[i]] ] for i in sea_adap_ass._popdyn_model._population_indices ], op=r'\to' ) )

ltx.write( 'So the condition for increase in guest investment is' )
ltx.write_block( sea_adap_ass_formal._S[a_indexer[(seamodel.type_g,0)]] > 0 )

ltx.write( 'And for increase in host investment' )
ltx.write_block( sea_adap_ass_formal._S[a_indexer[(seamodel.type_H,0)]] > 0 )

ltx.close()
save_session('sea-ass')
</source-file>

<project-file filename=sea-ass.sage.out.tex/>

<project-file filename=sea-ass-ts.svg/>

So here we see that both invest positively in association.

<project-file filename=sea-ass-sel.tex/>

_I.e._ marginal increase in benefit exceeds marginal increase in cost.
Marginal because cost and benefit are balanced at each population equilibrium.
Due to the factor of $$\hat{N}$$ or $$\hat{n}$$, I wonder if the net balance of cost/benefit could decrease rather than increase.

So either investment in association will rise provided benefit rises faster than
cost, and stop when the derivatives become equal.

We have assumed functional forms such that benefit increases more quickly
than cost near zero investment, so investment rises from zero until the
marginal benefit no longer exceeds marginal cost.

# Evolution of transfer

Maybe transfer, when association is held fixed, will behave similarly.

<source-file filename=sea-tran.sage.step display=none>
# requires: sea-down.sobj
# produces: sea-tran.sage.out.tex
# produces: sea-tran-ts.svg sea-tran-sel.tex
from sage.all import * 
from sage.misc.latex import _latex_file_
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings
from seamodel import *

load_session( 'sea-down' )
for k,l in _save_symbols.iteritems(): SR.symbol( k, latex_name=l ) 

ltx = dynamicalsystems.latex_output( 'sea-tran.sage.out.tex' )

sea_tran = sea_f.bind( base_b, fixed_ass_b, diag_tran_b )

ltx.write( 'To study the incentive structure for transfer, we set', diag_tran_b, fixed_ass_b )

ltx.write( 'Dynamics with transfer only:', sea_f.bind( base_b, fixed_ass_b ) )
ltx.write( 'Or', sea_tran )

sea_adap_tran_formal = sea_adap_f.bind( base_b, fixed_ass_b )
sea_adap_tran = sea_adap_tran_formal.bind( diag_tran_b )
ltx.write( 'And its adaptive dynamics is' )
ltx.write( sea_adap_tran_formal, 'Or ', sea_adap_tran )

sea_adap_tran.bind_in_place( seaquil[0], p=1 )
#ltx.write( 'With equilibrium populations is', sea_adap_tran )
#ltx.write( 'And at starting point ', vector( [ starting_comm(v) for v in sea_adap_tran._vars ] ), ' is', starting_comm(sea_adap_tran) )

adap_traj = sea_adap_tran.solve( starting_comm )
adap_traj.plot( 't', [ t_indexer[i] for i in sea_adap_tran._popdyn_model._population_indices ] ).save( filename='sea-tran-ts.svg', figsize=(4,3) )

ltx.close()

ltx = dynamicalsystems.latex_output( 'sea-tran-sel.tex' )

ltx.write( 'The selective pressures on investment are' )
ltx.write( dynamicalsystems.dgroup( [ [ t_indexer[i], sea_adap_tran_formal._S[t_indexer[i]] ] for i in sea_adap_tran._popdyn_model._population_indices ], op=r'\to' ) )

ltx.write( 'So the condition for increase in guest investment is' )
ltx.write_block( sea_adap_tran_formal._S[t_indexer[(seamodel.type_g,0)]] > 0 )

ltx.write( 'And for increase in host investment' )
ltx.write_block( sea_adap_tran_formal._S[t_indexer[(seamodel.type_H,0)]] > 0 )

ltx.close()
save_session('sea-tran')
</source-file>

<project-file filename=sea-tran.sage.out.tex/>

To evaluate the dynamics we use $$p=1$$.

<project-file filename=sea-tran-ts.svg/>

<project-file filename=sea-tran-sel.tex/>

So yes, it's very similar. Investment in transfer increases when the
marginal increase in benefit exceeds the marginal increase in cost.

The functions we chose have benefit changing more rapidly than
cost near zero, so both players respond by shifting
away from zero investment.  Since we've made transfer benefit guests
at the expense of hosts, guest invest in it and hosts invest in
stopping it.  The race quits when the cost of investment becomes
equally marginally significant.

# Adaptation in the full model

And when both association and transfer are up for adaptation?

<source-file filename=sea-all.sage.step display=none>
# requires: sea-down.sobj
# produces: sea-all.sage.out.tex sea-all-sel.tex
# produces: sea-all-ts.svg sea-all-values.svg
# produces: sea-all-ts2.svg sea-all-values2.svg
from sage.all import * 
from sage.misc.latex import _latex_file_
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings
from seamodel import *

load_session( 'sea-down' )
for k,l in _save_symbols.iteritems(): SR.symbol( k, latex_name=l ) 

ltx = dynamicalsystems.latex_output( 'sea-all.sage.out.tex' )

sea_all = sea_f.bind( base_b, exp_ass_b, diag_tran_b )

ltx.write( 'To study the incentive structure for transfer, we set', exp_ass_b, diag_tran_b )

ltx.write( 'Dynamics:', sea_f.bind( base_b ) )
ltx.write( 'Or', sea_all )

sea_adap_all_formal = sea_adap_f.bind( base_b )
sea_adap_all = sea_adap_all_formal.bind( exp_ass_b, diag_tran_b )
ltx.write( 'And its adaptive dynamics is' )
ltx.write( sea_adap_all_formal, 'Or ', sea_adap_all )

sea_adap_all.bind_in_place( p=1 )
sea_adap_all_n = sea_adap_all.bind( seaquil[0] )

adap_traj = sea_adap_all_n.solve( starting_comm )
adap_traj.plot( 't', sea_adap_all_n._vars ).save( filename='sea-all-ts.svg', figsize=(4,3) )

adap_traj.plot( 't',
	[ SR('p(x_a_0,X_a_0)'), SR('b(x_t_0,X_t_0)'), SR('B(x_t_0,X_t_0)'),
	  SR('c_t(x_t_0)'), SR('c_a(x_a_0)'), SR('C_t(X_t_0)'), SR('C_a(X_a_0)'),
	]
).save( filename='sea-all-values.svg', figsize=(4,3) )

scomm2 = starting_comm.bind( X_t_0=0.008 )
adap_traj = sea_adap_all_n.solve( scomm2 )
adap_traj.plot( 't', sea_adap_all_n._vars ).save( filename='sea-all-ts2.svg', figsize=(4,3) )

adap_traj.plot( 't',
	[ SR('p(x_a_0,X_a_0)'), SR('b(x_t_0,X_t_0)'), SR('B(x_t_0,X_t_0)'),
	  SR('c_t(x_t_0)'), SR('c_a(x_a_0)'), SR('C_t(X_t_0)'), SR('C_a(X_a_0)'),
	]
).save( filename='sea-all-values2.svg', figsize=(4,3) )

scomm3 = dynamicalsystems.Bindings( x_a_0=0, x_t_0=0, X_a_0=0.001, X_t_0=0.001 )
adap_traj = sea_adap_all_n.solve( scomm3 )
adap_traj.plot( 't', sea_adap_all_n._vars ).save( filename='sea-all-ts3.svg', figsize=(4,3) )

adap_traj.plot( 't',
	[ SR('p(x_a_0,X_a_0)'), SR('b(x_t_0,X_t_0)'), SR('B(x_t_0,X_t_0)'),
	  SR('c_t(x_t_0)'), SR('c_a(x_a_0)'), SR('C_t(X_t_0)'), SR('C_a(X_a_0)'),
	  diff( SR('p(x_a_0,X_a_0)'), SR('x_a_0') ),
	  diff( SR('c_a(x_a_0)'), SR('x_a_0') )
	]
).save( filename='sea-all-values3.svg', legend_loc='right', figsize=(4,3) )

ltx.close()
save_session('sea-all')
</source-file>

<project-file filename=sea-all.sage.out.tex/>

This is as above, except that in investment in association, the impact of
the probability of association is modulated by the consequences of transfer,
which can be positive or negative.  Previously that consequence was fixed
at a constant positive value.

<project-file filename=sea-all-ts.svg/>

So here both guest and host become anti-association, while their contributions
to transfer diverge to strong opposite values.  Why is that?

<project-file filename=sea-all-values.svg/>

Could it be bistable, and the guest, who is getting hurt initially by the
transfer, drives the polarization?

Let's try different initial conditions

<project-file filename=sea-all-ts2.svg/>

<project-file filename=sea-all-values2.svg/>

I am puzzled why $$x_{a_0}$$ goes downward.  Given that it's

\[* \dot{x}_{a0} = \left[ \hat{N}_0 ( b(x_{t0},X_{t0}) - c_t(x_{t0}) ) \partial_1 p(x_{a0},X_{a0}) - \hat{N}_0 \partial_1 c_a(x_{a0}) - \partial_1 c_g(x_{a0}) \right] \hat{n}_0 \]

with $$b-c_t = 0.008 >0$$, $$\partial_1 p = 0.25 > 0$$, $$\partial_1 c_a = 0.02$$,
and $$\partial_1 c_g = 0$$,
it looks like the situation is that the $$p$$ part is being dominated by
the cost $$c_a$$.

So how about this:

<project-file filename=sea-all-ts3.svg/>

<project-file filename=sea-all-values3.svg/>

# A cooperative example?

How to make this model select for mutualism.

<source-file filename=sea-up.sage.step display=none>
# requires: sea-down.sobj
# produces: sea-up.sage.out.tex sea-up-sel.tex
# produces: sea-up-ts.svg sea-up-values.svg
from sage.all import * 
from sage.misc.latex import _latex_file_
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings
from seamodel import *

load_session( 'sea-down' )
for k,l in _save_symbols.iteritems():
	#print k,l
	SR.symbol( k, latex_name=l ) 

ltx = dynamicalsystems.latex_output( 'sea-up.sage.out.tex' )

heavy_k_b = Bindings( k=20, K=20 )
vw_up_b = Bindings( V=15/2, W=1, v=1, w=15/2 )

sea_lin = sea_f.bind( heavy_k_b ).bind( base_b, linear_ass_b )
sea_vw = sea_lin.bind( linear_tran_b )
sea_up = sea_vw.bind( vw_up_b )

sea_adap_up_formal = sea_adap_f.bind( heavy_k_b ).bind( base_b )
sea_adap_lin = sea_adap_up_formal.bind( linear_ass_b )
sea_adap_vw = sea_adap_lin.bind( linear_tran_b )

ltx.write( 'To study the incentive structure for transfer, we set', heavy_k_b, linear_ass_b, linear_tran_b, sea_adap_vw )

from dynamicalsystems import dgroup
ltx.write( 'Equilibrium conditions are\n',
  dgroup( [ [ SR(x) for x in l ] for l in
      [ [ 'W', '2X_t' ],
	[ 'Vx_t', 'X_t^2 - WX_t + 8X_a', '8X_a - X_t^2' ],
	[ 'v', '2x_t' ],
	[ 'wX_t', 'x_t^2 - vx_t + 8x_a', '8x_a - x_t^2' ]
      ]
  ], '=' ),
  'So to have all $x$ values equal to $1/2$, we set\n',
  vw_up_b
)

sea_adap_up = sea_adap_vw.bind( vw_up_b )
ltx.write( 'for ', sea_adap_up )

sea_adap_up_n = sea_adap_up.bind( seaquil[0] )
a_g_H = SR.symbol('a_g_H',latex_name='a_{gH}' )
a_H_g = SR.symbol('a_H_g',latex_name='a_{Hg}' )
sea_adap_up_n.bind(
    a_g_H = SR('(B(x_t_0,X_t_0)-C_t(X_t_0))*p(x_a_0,X_a_0) - C_a(X_a_0)'),
    a_H_g = SR('(b(x_t_0,X_t_0)-c_t(x_t_0))*p(x_a_0,X_a_0) - c_a(x_a_0)')
)

adap_traj = sea_adap_up_n.solve( starting_comm, step=0.002 )
adap_traj.plot( 't', sea_adap_up_n._vars ).save( filename='sea-up-ts.svg', figsize=(4,3) )

adap_traj.plot( 't',
	[ SR('p(x_a_0,X_a_0)'), SR('b(x_t_0,X_t_0)'), SR('B(x_t_0,X_t_0)'),
	  'a_g_H', 'a_H_g'
	] + sea_adap_up._popdyn_model.equilibrium_vars()
).save( filename='sea-up-values.svg', figsize=(4,3) )

adap_traj.plot( 't',
	[ SR('c_t(x_t_0)'), SR('c_a(x_a_0)'), SR('C_t(X_t_0)'), SR('C_a(X_a_0)'),
	]
).save( filename='sea-up-c-values.svg', figsize=(4,3) )

ltx.close()
save_session('sea-up')
</source-file>

<project-file filename=sea-up.sage.out.tex/>

<project-file filename=sea-up-ts.svg/>

<project-file filename=sea-up-values.svg/>

<project-file filename=sea-up-c-values.svg/>

Why does it stop?  Because the population equilibrium stops being viable,
it looks like. Loss of $$B$$-stability.
I'll probably want to look into the $$B$$-stability criteria, try to
avoid this explosion.  At first, I'll leave it as it is, since initial
increase in mutualism is enough for my purposes.

# The interactions

<source-file filename=sea-up-a.sage.step display=none>
# requires: sea-up.sobj
# produces: sea-up-a.sage.out.tex
# produces: sea-up-a.svg
from sage.all import * 
from sage.misc.latex import _latex_file_
import dynamicalsystems, lotkavolterra
from dynamicalsystems import indexer, subscriptedsymbol, Bindings
from seamodel import *

load_session( 'sea-up' )
for k,l in _save_symbols.iteritems():
	#print k,l
	SR.symbol( k, latex_name=l ) 

ltx = dynamicalsystems.latex_output( 'sea-up-a.sage.out.tex' )

type_letters = [ 0, 0 ]
type_letters[seamodel.type_H] = H
type_letters[seamodel.type_g] = g
class sea_a_indexer(dynamicalsystems.indexer_2d_inner):
	def __getitem__(self, j):
		return subscriptedsymbol(self._f, type_letters[self._i[0]], self._i[1], type_letters[j[0]], j[1])

class sea_r_indexer(dynamicalsystems.indexer):
	def __getitem__(self, i):
		return subscriptedsymbol(self._f, type_letters[i[0]], i[1])

uplv = lotkavolterra.LotkaVolterraAdaptiveDynamics( sea_adap_up,
	a_name_indexer=dynamicalsystems.indexer_2d( 'a', inner_class=sea_a_indexer ),
	r_name_indexer=sea_r_indexer('r')
)

uplv_n = lotkavolterra.LotkaVolterraAdaptiveDynamics( sea_adap_up_n,
	a_name_indexer=dynamicalsystems.indexer_2d( 'a', inner_class=sea_a_indexer ),
	r_name_indexer=sea_r_indexer('r')
)

ltx.write( 'For $a_{gH}$,\n' )
ltx.write( dynamicalsystems.dgroup(
      [ [ SR('A'), uplv.A_pair( (seamodel.type_g,0), (seamodel.type_H,0) ) ],
	[ SR('S'), uplv.S_pair( (seamodel.type_g,0), (seamodel.type_H,0) ) ],
	[ SR('D'), uplv.D_pair( (seamodel.type_g,0), (seamodel.type_H,0) ) ],
	[ SR.symbol('I'), uplv.I_pair( (seamodel.type_g,0), (seamodel.type_H,0) ) ],
	[ SR('dA/dt'), uplv.dAdt_pair( (seamodel.type_g,0), (seamodel.type_H,0) ) ],
      ], '='
) )

ltx.close()

aap = lotkavolterra.plot_aij_with_arrows( adap_traj, uplv_n )
aap.axes_labels( [ '$a_{ij}$', '$a_{ji}$' ] )
aap.save( 'sea-up-a.svg', figsize=(5,5) )
</source-file>

<project-file filename=sea-up-a.sage.out.tex/>

<project-file filename=sea-up-a.svg/>

