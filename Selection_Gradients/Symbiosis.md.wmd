---
layout: page
title: "Symbiosis in the Sea"
wmd_project: Selection_Gradients
---
This model for symbiotic guest-host interaction in the sea is based on
Roughgarden's 1975 paper, which considers selection on the guest only.

Here we add fairly arbitrary functional forms to include the host dynamics
in the model, which retaining the Lotka-Volterra form which lets us looks
at adaptive motion in the plane of interaction coefficients.

The guest dynamics:

$$\frac{dN_g}{N_g dt} = r_g + a_{gH} N_H$$.

We assume no $$g$$-$$g$$ interaction.

The host strategy/phenotype is

* $$X_c$$: investment for/against (+/-) colonization by guest
* $$X_m$$: investment for/against exploitation by guest (given colonization).

$$\frac{dN_H}{N_H dt} = r_H + a_{Hg} N_g + a_{HH} N_H$$

let $$a_{HH}$$ be constant, uninteresting to adaptation.

Investment has cost so $$r_H$$ is at maximum at $$X_c=X_m=0$$.

I propose

* $$p(x_c,X_c)$$: probability of colonization per pair of individuals

on host side:

* $$C_g(X_c)$$: general (density independent) cost of investment re colonization
* $$C_c(X_c)$$: per-guest cost of investment re colonization
* $$C_m(X_m)$$: cost of investment re exploitation
* (and add density-independent investment re exploitation?)
* $$B(x_m,X_m)$$: benefit (+/-) to host of the guest's exploitation

on guest side:

* $$c_g(x_c)$$: search cost
* $$c_c(x_c)$$: cost of colonization after host is found
* $$c_m(x_m)$$: cost of investment in exploitation
* $$b(x_m,X_m)$$: benefit to guest

So we then have

$$\frac{dN_g}{N_g dt} = r_0 - c_g(x_c) + (p(x_c,X_c) (b(x_m,X_M) - c_m(x_m)) - c_c(x_c)) N_H$$

$$\frac{dN_H}{N_H dt} = R_0 - C_g(X_c) + (p(x_c,X_c) (B(x_m,X_m) - C_m(X_m)) - C_c(X_c)) N_g$$

This is oddly symmetric - maybe I abstracted it too much.  But one asymmetry is that the benefit to the host can be positive or negative, while it's assumed positive for the guest.  Thus the host might want to invest in defense against guests, while guests will always want to colonize and exploit.

<source-file filename=seamodel.py display=none>
from sage.all import * 
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings

# Model organized as follows:
#  population index is (type, number), with type either g or H

type_H, type_g = 0, 1
var('H g m c')

## indexing functions for sea model
def Xfn( (t,i) ):
	return subscriptedsymbol( 'N', H if t == type_H else g, i )
def Rfn( (t,i) ):
	return subscriptedsymbol( 'R' if t == type_H else 'r', i )
def pfn( (t,i) ):
	return indexer( lambda (s,j): subscriptedsymbol( 'p', i, j ) )
def bfn( (t,i) ):
	return indexer( lambda (s,j): subscriptedsymbol( 'b', i, j ) )
def Bfn( (t,i) ):
	return indexer( lambda (s,j): subscriptedsymbol( 'B', i, j ) )
def cgfn( (t,i) ):
	return subscriptedsymbol( 'C' if t == type_H else 'c', g, i )
def ccfn( (t,i) ):
	return subscriptedsymbol( 'C' if t == type_H else 'c', c, i )
def cmfn( (t,i) ):
	return subscriptedsymbol( 'C' if t == type_H else 'c', m, i )
def Kfn( (t,i) ):
	return subscriptedsymbol( 'K' if t == type_H else 'k', i )

class SeaSymbiosisModel(dynamicalsystems.PopulationDynamicsSystem):
    def __init__(
	self,
	x_indices=None,
	X = indexer( Xfn ),
	r_indexer = indexer( Rfn ),
	p_indexer = indexer( pfn ),
	b_indexer = indexer( bfn ),
	B_indexer = indexer( Bfn ),
	cg_indexer = indexer( cgfn ),
	cc_indexer = indexer( ccfn ),
	cm_indexer = indexer( cmfn ),
	K_indexer = indexer( Kfn ),
	bindings=Bindings()):
	self._indexers = { 'X': X,
		'r':r_indexer, 'p':p_indexer, 'b':b_indexer, 'B':B_indexer,
		'c_g':cg_indexer, 'c_c':cc_indexer, 'c_m':cm_indexer,
		'K':K_indexer }
	#print 'debug:', m_indexer[(type_H,0)], 'done'; sys.stdout.flush()
	from sage.symbolic.function_factory import function
	self._names = dict( 
		#[ (n, SR.symbol(n)) for n in ('r_0', 'R_0') ] +
		#[ (n, function(n)) for n in ('p', 'c_g', 'c_c', 'c_m', 'b', 'C_g', 'C_c', 'C_m', 'B') ] +
		self._indexers.items()
	)
	super(SeaSymbiosisModel,self).__init__(
	    [], x_indices, X, bindings=bindings
	)
    def flow(self):
	return self.make_flow( **self._names )
    def make_flow(self, X, r, p, c_g, c_c, c_m, b, B, K ):
	return dict(
	    [ (X[g], X[g]*(r[g] - c_g[g] +
		sum( (p[g][h] * (b[g][h] - c_m[g]) - c_c[g])*X[h]
		    for h in self._population_indices if h[0] == type_H ) +
		sum( - K[g1] * X[g1]
		    for g1 in self._population_indices if g1[0] == type_g ) )
	      ) for g in self._population_indices if g[0] == type_g ] +
	    [ (X[h], X[h]*(r[h] - c_g[h] +
		sum( (p[g][h] * (B[g][h] - c_m[h]) - c_c[h])*X[g]
		    for g in self._population_indices if g[0] == type_g ) +
		sum( - K[h1] * X[h1]
		    for h1 in self._population_indices if h1[0] == type_H ) )
	      ) for h in self._population_indices if h[0] == type_H ]
	)
    def mutate(self, resident_index):
	t,i = resident_index
	mutant_index = ( t, 1 + max( j for tt,j in self._population_indices if tt == t ) )
	self.set_population_indices( self._population_indices + [ mutant_index ] )
	return mutant_index

## used in adaptive dynamics
def bcfn( (t,i) ):
	return ( Bfn( (type_g,0) )[(t,i)] if t == type_H
		else bfn( (t,i) )[(type_H,0)] )
def pcfn( (t,i) ):
	return ( pfn( (type_g,0) )[(t,i)] if t == type_H
		else pfn( (t,i) )[(type_H,0)] )

def xmfn( (t,i) ):
	return subscriptedsymbol( 'X' if t == type_H else 'x', m, i)
def xcfn( (t,i) ):
	return subscriptedsymbol( 'X' if t == type_H else 'x', c, i)
m_indexer = indexer( xmfn )
c_indexer = indexer( xcfn )

def rffn( (t,i) ):
	return function('R' if t == type_H else 'r')(c_indexer[(t,i)],m_indexer[(t,i)])
def cgffn( ix ):
	return function('c_g')(c_indexer[ix])
def ccffn( ix ):
	return function('c_c')(c_indexer[ix])
def cmffn( ix ):
	return function('c_m')(c_indexer[ix])
def pffn( ix ):
	return indexer( lambda jx: function('p')(c_indexer[ix],c_indexer[jx]) )
def bffn( ix ):
	return indexer( lambda jx: function('b')(m_indexer[ix],m_indexer[jx]) )
def Bffn( ix ):
	return indexer( lambda jx: function('B')(m_indexer[ix],m_indexer[jx]) )
def Kffn( (t,i) ):
	return SR.symbol( 'K' if t == type_H else 'k' )
def varfix( vartex ):
	for st,lx in vartex.iteritems():
		var( st, latex_name=lx )
</source-file>

<source-file filename=sea.sage.step display=none>
# requires: seamodel.py
# produces: sea.sobj sea.sage.out.tex
from sage.all import * 
from sage.misc.latex import _latex_file_
import seamodel, dynamicalsystems

# now that I've defined the general resource-competition model, let's
# create a 1-resource, 1-population instantiation to work with
sea = seamodel.SeaSymbiosisModel(
    x_indices=[(seamodel.type_H,0),(seamodel.type_g,0)]
)

ltx = dynamicalsystems.latex_output( 'sea.sage.out.tex' )
ltx.write( 'The dynamics:' )
ltx.write( sea )

ltx.close()
save_session( 'sea' )
</source-file>

<project-file filename=sea.sage.out.tex/>

<source-file filename=sea-adap.sage.step display=none>
# requires: sea.sobj
# produces: sea-adap.sobj sea-adap.sage.out.tex
from sage.all import * 
from sage.misc.latex import _latex_file_
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings
from seamodel import *

load_session( 'sea' )
ltx = dynamicalsystems.latex_output( 'sea-adap.sage.out.tex' )

sea_adap_c = dynamicalsystems.AdaptiveDynamicsModel( 
    sea,
    [ sea._indexers[s] for s in ('r', 'c_g','c_c','c_m') ] +
    [ indexer( bcfn ), indexer( pcfn ) ],
    equilibrium=sea.symbolic_equilibria()
)

ltx.write( 'Whence the selective pressure on the ecological quantities is' )
ltx.write_environment( 'align*', '\\\\\n  '.join( r'\frac{d%s}{dt} &\propto %s' % (dynamicalsystems.latex_math(v), dynamicalsystems.latex_math(sea_adap_c._S[v])) for v in sea_adap_c._vars ) )

## phenotype indexers for sea correlation

from sage.symbolic.function_factory import function
sea_f = SeaSymbiosisModel(
	x_indices=[(type_H,0),(type_g,0)],
	r_indexer =indexer( rffn ),
	cg_indexer=indexer( cgffn ),
	cc_indexer=indexer( ccffn ),
	cm_indexer=indexer( cmffn ),
	p_indexer =indexer( pffn ),
	b_indexer =indexer( bffn ),
	B_indexer =indexer( Bffn ),
	K_indexer =indexer( Kffn )
)

ltx.write( 'Dynamics with constraints:' )
ltx.write( sea_f )

sea_adap_f = dynamicalsystems.AdaptiveDynamicsModel( 
    sea_f,
    [ c_indexer, m_indexer ],
    equilibrium=sea_f.symbolic_equilibria(),
    workaround_limits=True
)

ltx.write( 'And selective pressure on constraining characters is' )
ltx.write_environment( 'align*', '\\\\\n  '.join( r'\frac{d%s}{dt} &\propto %s' % (dynamicalsystems.latex_math(v), dynamicalsystems.latex_math(sea_adap_f._S[v])) for v in sea_adap_f._vars ) )

ltx.close()

_save_symbols = { sv:lv for sv,lv in ( (str(v), latex(v)) for v in sage.symbolic.ring.pynac_symbol_registry.values() ) if sv != lv }
save_session('sea-adap')

</source-file>

<project-file filename=sea-adap.sage.out.tex/>

<source-file filename=sea-down.sage.step display=none>
# requires: sea-adap.sobj
# produces: sea-down.sobj sea-down.sage.out.tex
# produces: sea-down-test.svg
from sage.all import * 
from sage.misc.latex import _latex_file_
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings
from seamodel import *

load_session( 'sea-adap' )
for k,l in _save_symbols.iteritems(): SR.symbol( k, latex_name=l ) 
ltx = dynamicalsystems.latex_output( 'sea-down.sage.out.tex' )

## version of tradeoffs with excessive cost to guest of colonization,
## leading to no symbiosis
var('y')
down_b = Bindings(
    dynamicalsystems.FunctionBindings(
	## R_0 maximized at x_c == x_m == 0
	R = SR(1).function(x,y),
	r = SR(1).function(x,y),
	## density independent cost re colonization
	C_g = SR(0).function(x),
	c_g = SR(0).function(x),
	## cost re colonization per interaction
	C_c = (x^2).function(x),
	c_c = (x^2).function(x),
	## cost re exploitation per interaction
	C_m = (x^2).function(x),
	c_m = (x^2).function(x),
	## prob of colonization
	p = exp(x+y-1).function(x,y),
	## benefit to guest of exploitation
	b = SR(1).function(x,y), #x.function(x,y),
	## benefit to host of exploitation
	B = SR(-1).function(x,y), #y.function(x,y),
    ),
    K = 1, k=1, gamma=1
)

ltx.write( 'Here are some pessimistic bindings:', down_b )
sea_down = down_b(sea_f)

ltx.write( 'Dynamics with pessimistic functions:' )
ltx.write( sea_down )

starting_comm = Bindings( **{ x:0 for x in ('x_c_0', 'x_m_0', 'X_c_0','X_m_0') } )
starting_pop = Bindings( N_H_0=0.1, N_g_0=0.2 )
#test_dyn = starting_comm( sea_down ).solve( starting_pop )
#test_dyn.plot( 't', sea_down._vars ).save( filename='sea-down-test.svg', figsize=(4,3) )

sea_adap_down = down_b(sea_adap_f)
ltx.write( 'And pessimistic adaptive dynamics is' )
ltx.write( sea_adap_down )

sea_adap_down.bind_in_place( sea_down.interior_equilibria()[0] )
#ltx.write( 'With equilibrium populations is', sea_adap_down )
ltx.write( 'And at starting point $(0,0)$ is', starting_comm(sea_adap_down) )

adap_traj = sea_adap_down.solve( starting_comm )
adap_traj.plot( 't', sea_adap_down._vars ).save( filename='sea-down-test.svg', figsize=(4,3) )

sdx = sea_adap_down.limit( X_c_0=0, X_m_0=0 )
ltx.write( sdx )
vfp = sdx.plot_vector_field( (SR('x_c_0'),-1,1), (SR('x_m_0'),-1,1) )
vfp.save( filename='sea-vf-x.svg', figsize=(4,4) )

sdx = sea_adap_down.limit( x_c_0=0, x_m_0=0 )
ltx.write( sdx )
vfp = sdx.plot_vector_field( (SR('X_c_0'),-1,1), (SR('X_m_0'),-1,1) )
vfp.save( filename='sea-vf-X.svg', figsize=(4,4) )

ltx.close()
save_session('sea-down')
exit(0r)
</source-file>

<project-file filename=sea-down.sage.out.tex/>

<project-file filename=sea-down-test.svg/>

<project-file filename=sea-vf-x.svg/>

<project-file filename=sea-vf-X.svg/>
