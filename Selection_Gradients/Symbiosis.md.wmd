---
layout: page
title: "Symbiosis in the Sea"
wmd_project: Selection_Gradients
---
This model for symbiotic guest-host interaction in the sea is based on
Roughgarden's 1975 paper, which considers selection on the guest only.

Here we add fairly arbitrary functional forms to include the host dynamics
in the model, which retaining the Lotka-Volterra form which lets us looks
at adaptive motion in the plane of interaction coefficients.

The guest dynamics:

$$\frac{dN_g}{N_g dt} = r_g + a_{gH} N_H$$.

We assume no $$g$$-$$g$$ interaction.

The host strategy/phenotype is

* $$X_c$$: investment for/against (+/-) colonization by guest
* $$X_m$$: investment for/against exploitation by guest (given colonization).

$$\frac{dN_H}{N_H dt} = r_H + a_{Hg} N_g + a_{HH} N_H$$

let $$a_{HH}$$ be constant, uninteresting to adaptation.

Investment has cost so $$r_H$$ is at maximum at $$X_c=X_m=0$$.

I propose

* $$p(x_c,X_c)$$: probability of colonization per pair of individuals

on host side:

* $$C_g(X_c)$$: general (density independent) cost of investment re colonization
* $$C_c(X_c)$$: per-guest cost of investment re colonization
* $$C_m(X_m)$$: cost of investment re exploitation
* (and add density-independent investment re exploitation?)
* $$B(x_m,X_m)$$: benefit (+/-) to host of the guest's exploitation

on guest side:

* $$c_g(x_c)$$: search cost
* $$c_c(x_c)$$: cost of colonization after host is found
* $$c_m(x_m)$$: cost of investment in exploitation
* $$b(x_m,X_m)$$: benefit to guest

So we then have

$$\frac{dN_g}{N_g dt} = r_0 - c_g(x_c) + (p(x_c,X_c) (b(x_m,X_M) - c_m(x_m)) - c_c(x_c)) N_H$$

$$\frac{dN_H}{N_H dt} = R_0 - C_g(X_c) + (p(x_c,X_c) (B(x_m,X_m) - C_m(X_m)) - C_c(X_c)) N_g$$

This is oddly symmetric - maybe I abstracted it too much.  But one asymmetry is that the benefit to the host can be positive or negative, while it's assumed positive for the guest.  Thus the host might want to invest in defense against guests, while guests will always want to colonize and exploit.

<source-file filename=seamodel.py display=none>
from sage.all import * 
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings

# Model organized as follows:
#  population index is (type, number), with type either g or H

type_H, type_g = 0, 1
var('H g m c')
class SeaSymbiosisModel(dynamicalsystems.PopulationDynamicsSystem):
    def __init__(
	self,
	x_indices=None,
	X = indexer( lambda (t,i): subscriptedsymbol( 'N', H if t == type_H else g, i ) ),
	r_indexer = indexer( lambda (t,i):
			subscriptedsymbol( 'R' if t == type_H else 'r', i ) ),
	p_indexer = indexer( lambda (t,i): indexer( lambda (s,j):
			subscriptedsymbol( 'p', i, j ) ) ),
	b_indexer = indexer( lambda (t,i): indexer( lambda (s,j):
			subscriptedsymbol( 'b', i, j ) ) ),
	B_indexer = indexer( lambda (t,i): indexer( lambda (s,j):
			subscriptedsymbol( 'B', i, j ) ) ),
	cg_indexer = indexer( lambda (t,i): subscriptedsymbol( 'C' if t == type_H else 'c', g, i ) ),
	cc_indexer = indexer( lambda (t,i): subscriptedsymbol( 'C' if t == type_H else 'c', c, i ) ),
	cm_indexer = indexer( lambda (t,i): subscriptedsymbol( 'C' if t == type_H else 'c', m, i ) ),
	bindings=Bindings()):
	self._indexers = { 'X': X,
		'r':r_indexer, 'p':p_indexer, 'b':b_indexer, 'B':B_indexer,
		'c_g':cg_indexer, 'c_c':cc_indexer, 'c_m':cm_indexer }
	#print 'debug:', m_indexer[(type_H,0)], 'done'; sys.stdout.flush()
	from sage.symbolic.function_factory import function
	self._names = dict( 
		#[ (n, SR.symbol(n)) for n in ('r_0', 'R_0') ] +
		#[ (n, function(n)) for n in ('p', 'c_g', 'c_c', 'c_m', 'b', 'C_g', 'C_c', 'C_m', 'B') ] +
		self._indexers.items()
	)
	super(SeaSymbiosisModel,self).__init__(
	    [], x_indices, X, bindings=bindings
	)
    def flow(self):
	return self.make_flow( **self._names )
    def make_flow(self, X, r, p, c_g, c_c, c_m, b, B ):
	return dict(
	    [ (X[g], X[g]*(r[g] - c_g[g] +
		sum( (p[g][h] * (b[g][h] - c_m[g]) - c_c[g])*X[h]
		    for h in self._population_indices if h[0] == type_H ) )
	      ) for g in self._population_indices if g[0] == type_g ] +
	    [ (X[h], X[h]*(r[h] - c_g[h] +
		sum( (p[g][h] * (B[g][h] - c_m[h]) - c_c[h])*X[g]
		    for g in self._population_indices if g[0] == type_g ) )
	      ) for h in self._population_indices if h[0] == type_H ]
	)
    def mutate(self, resident_index):
	t,i = resident_index
	mutant_index = ( t, 1 + max( j for tt,j in self._population_indices if tt == t ) )
	self.set_population_indices( self._population_indices + [ mutant_index ] )
	return mutant_index
</source-file>

<source-file filename=sea.sage.step display=none>
# requires: seamodel.py
# produces: sea.sobj sea.sage.out.tex
from sage.all import * 
from sage.misc.latex import _latex_file_
import seamodel, dynamicalsystems

# now that I've defined the general resource-competition model, let's
# create a 1-resource, 1-population instantiation to work with
sea = seamodel.SeaSymbiosisModel(
    x_indices=[(seamodel.type_H,0),(seamodel.type_g,0)]
)

ltx = dynamicalsystems.latex_output( 'sea.sage.out.tex' )
ltx.write( 'The dynamics:' )
ltx.write( sea )

ltx.close()
save_session( 'sea' )
</source-file>

<project-file filename=sea.sage.out.tex/>

<source-file filename=sea-adap.sage.step display=none>
# requires: sea.sobj
# produces: sea-adap.sobj sea-adap.sage.out.tex
from sage.all import * 
from sage.misc.latex import _latex_file_
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings
from seamodel import *

load_session( 'sea' )
ltx = dynamicalsystems.latex_output( 'sea-adap.sage.out.tex' )
sea = seamodel.SeaSymbiosisModel(
    x_indices=[(seamodel.type_H,0),(seamodel.type_g,0)]
)

sea_adap_c = dynamicalsystems.AdaptiveDynamicsModel( 
    sea,
    [ sea._indexers[s] for s in ('r', 'c_g','c_c','c_m') ] +
    [ indexer( lambda (t,i):
	sea._indexers['B'][(seamodel.type_g,0)][(t,i)] if t == seamodel.type_H
	else sea._indexers['b'][(t,i)][(seamodel.type_H,0)] ),
      indexer( lambda (t,i):
	sea._indexers['p'][(seamodel.type_g,0)][(t,i)] if t == seamodel.type_H
	else sea._indexers['p'][(t,i)][(seamodel.type_H,0)] ) ]
)

ltx.write( 'Whence the selective pressure on the ecological quantities is' )
ltx.write_environment( 'align*', '\\\\\n  '.join( r'\frac{d%s}{dt} &\propto %s' % (dynamicalsystems.latex_math(v), dynamicalsystems.latex_math(sea_adap_c._S[v])) for v in sea_adap_c._vars ) )

## phenotype indexers for sea correlation

m_indexer = indexer( lambda (t,i): subscriptedsymbol( 'X' if t == seamodel.type_H else 'x', m, i) )
c_indexer = indexer( lambda (t,i): subscriptedsymbol( 'X' if t == seamodel.type_H else 'x', c, i) )

from sage.symbolic.function_factory import function
sea_f = seamodel.SeaSymbiosisModel(
	x_indices=[(seamodel.type_H,0),(seamodel.type_g,0)],
	r_indexer =indexer( lambda (t,i): function('R' if t == seamodel.type_H else 'r')(c_indexer[(t,i)],m_indexer[(t,i)]) ),
	cg_indexer=indexer( lambda ix: function('c_g')(c_indexer[ix]) ),
	cc_indexer=indexer( lambda ix: function('c_c')(c_indexer[ix]) ),
	cm_indexer=indexer( lambda ix: function('c_m')(m_indexer[ix]) ),
	p_indexer =indexer( lambda ix: indexer( lambda jx:
		function('p')(c_indexer[ix],c_indexer[jx]) ) ),
	b_indexer =indexer( lambda ix: indexer( lambda jx:
		function('b')(m_indexer[ix],m_indexer[jx]) ) ),
	B_indexer =indexer( lambda ix: indexer( lambda jx:
		function('B')(m_indexer[ix],m_indexer[jx]) ) )
)

ltx.write( 'Dynamics with constraints:' )
ltx.write( sea_f )

sea_adap_f = dynamicalsystems.AdaptiveDynamicsModel( 
    sea_f,
    [ c_indexer, m_indexer ]
)

ltx.write( 'And selective pressure on constraining characters is' )
ltx.write_environment( 'align*', '\\\\\n  '.join( r'\frac{d%s}{dt} &\propto %s' % (dynamicalsystems.latex_math(v), dynamicalsystems.latex_math(sea_adap_f._S[v])) for v in sea_adap_f._vars ) )

ltx.close()

save_session('sea-adap')
</source-file>

<project-file filename=sea-adap.sage.out.tex/>

<source-file filename=sea-down.sage.step display=none>
# requires: sea.sobj
# produces: sea-down.sobj sea-down.sage.out.tex
from sage.all import * 
from sage.misc.latex import _latex_file_
import dynamicalsystems
from dynamicalsystems import indexer, subscriptedsymbol, Bindings
from seamodel import *

load_session( 'sea' )
ltx = dynamicalsystems.latex_output( 'sea-down.sage.out.tex' )

m_indexer = indexer( lambda (t,i): subscriptedsymbol( 'X' if t == seamodel.type_H else 'x', m, i) )
c_indexer = indexer( lambda (t,i): subscriptedsymbol( 'X' if t == seamodel.type_H else 'x', c, i) )

## first make generic sea model, then bind the functions
from sage.symbolic.function_factory import function
sea_f = seamodel.SeaSymbiosisModel(
	x_indices=[(seamodel.type_H,0),(seamodel.type_g,0)],
	r_indexer =indexer( lambda (t,i): function('R' if t == seamodel.type_H else 'r')(c_indexer[(t,i)],m_indexer[(t,i)]) ),
	cg_indexer=indexer( lambda ix: function('c_g')(c_indexer[ix]) ),
	cc_indexer=indexer( lambda ix: function('c_c')(c_indexer[ix]) ),
	cm_indexer=indexer( lambda ix: function('c_m')(m_indexer[ix]) ),
	p_indexer =indexer( lambda ix: indexer( lambda jx:
		function('p')(c_indexer[ix],c_indexer[jx]) ) ),
	b_indexer =indexer( lambda ix: indexer( lambda jx:
		function('b')(m_indexer[ix],m_indexer[jx]) ) ),
	B_indexer =indexer( lambda ix: indexer( lambda jx:
		function('B')(m_indexer[ix],m_indexer[jx]) ) )
)

sea_adap_f = dynamicalsystems.AdaptiveDynamicsModel( 
    sea_f,
    [ c_indexer, m_indexer ],
    workaround_limits=True
)

#ltx.write( 'Adaptive dynamics debug output:\n' )
#ltx.write( sea_adap_f._debug_output._output._str )

## version of tradeoffs with excessive cost to guest of colonization,
## leading to no symbiosis
var('y')
down_b = Bindings( dynamicalsystems.FunctionBindings(
	## R_0 maximized at x_c == x_m == 0
	R = SR(1).function(x,y),
	r = SR(1).function(x,y),
	## density independent cost re colonization
	C_g = SR(0).function(x),
	c_g = SR(0).function(x),
	## cost re colonization per interaction
	C_c = (x^2).function(x),
	c_c = (x^2).function(x),
	## cost re exploitation per interaction
	C_m = (x^2).function(x),
	c_m = (x^2).function(x),
	## prob of colonization
	p = exp(x+y-1).function(x,y),
	## benefit to guest of exploitation
	b = x.function(x,y),
	## benefit to host of exploitation
	B = y.function(x,y)
) )

#ltx.write( 'bindings', down_b )

ltx.write( 'Dynamics with pessimistic functions:' )
ltx.write( down_b(sea_f) )

ltx.write( 'And pessimistic selective pressure is' )
ltx.write_environment(
	'align*', '\\\\\n  '.join( r'\frac{d%s}{dt} &\propto %s' % (
		dynamicalsystems.latex_math(v),
		dynamicalsystems.latex_math( down_b(sea_adap_f._S[v]).factor() )
	) for v in sea_adap_f._vars ) )

ltx.close()

save_session('sea-down')
</source-file>

<project-file filename=sea-down.sage.out.tex/>
